<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><!--THIS FILE IS GENERATED FROM AN XML MASTER. DO NOT EDIT (2)--><title>2. Development and obsolescence of programs – the programmer’s challenge and nightmare</title><meta http-equiv="x-ua-compatible" content="ie=edge" /><meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="description" content="Zapuščina napredne informatizacije / The Legacy of Advanced Informatization" /><meta name="keywords" content="Računalniški muzej, konferenca, zbornik" /><meta name="author" content="" /><meta name="generator" content="Text Encoding Initiative Consortium XSLT stylesheets" /><meta charset="utf-8" /><link href="https://www2.sistory.si/publikacije/themes/foundation/6/css/foundation.min.css" rel="stylesheet" type="text/css" /><link href="https://www2.sistory.si/publikacije/themes/css/foundation/6/sistory.css" rel="stylesheet" type="text/css" /><link href="https://cdnjs.cloudflare.com/ajax/libs/foundicons/3.0.0/foundation-icons.min.css" rel="stylesheet" type="text/css" /><link href="https://www2.sistory.si/publikacije/themes/plugin/TipueSearch/6.1/tipuesearch/css/normalize.css" rel="stylesheet" type="text/css" /><link href="https://www2.sistory.si/publikacije/themes/css/plugin/TipueSearch/6.1/my-tipuesearch.css" rel="stylesheet" type="text/css" /><link href="project.css" rel="stylesheet" type="text/css" /><script src="https://www2.sistory.si/publikacije/themes/foundation/6/js/vendor/jquery.js"></script><link href="https://www2.sistory.si/publikacije/themes/plugin/jstree/3.3.5/dist/themes/default/style.min.css" rel="stylesheet" type="text/css" /><script src="https://www2.sistory.si/publikacije/themes/plugin/jstree/3.3.5/dist/jstree.min.js"></script></head><body id="TOP" itemscope="itemscope" itemtype="http://www.tei-c.org/ns/1.0/" itemprop="TEI"><script src="tipuesearch_content.js"></script><script src="https://www2.sistory.si/publikacije/themes/plugin/TipueSearch/6.1/tipuesearch/tipuesearch_set.js"></script><script src="https://www2.sistory.si/publikacije/themes/plugin/TipueSearch/6.1/tipuesearch/tipuesearch.min.js"></script><div class="column row"><header xmlns:html="http://www.w3.org/1999/xhtml"><div class="hide-for-large"><div id="header-bar"><div class="title-bar" data-responsive-toggle="publication-menu" data-hide-for="large"><button class="menu-icon" type="button" data-toggle=""></button><div class="title-bar-title">Menu</div><div class="title-bar-right"><a class="title-bar-title" href="https://sistory.github.io/TheLegacyofAdvancedInformatization"><i class="fi-home" style="color:white;"></i></a></div><div id="publication-menu" class="hide-for-large"><ul class="vertical menu" data-drilldown="" data-options="backButton: &lt;li class=&#34;js-drilldown-back&#34;&gt;&lt;a tabindex=&#34;0&#34;&gt;Back&lt;/a&gt;&lt;/li&gt;;"><li><a href="index.html">Cover Page</a></li><li><a href="cip.html">Colophon</a></li><li><a href="toc.html">TOC</a></li><li><a href="preface-en.html">Front</a></li><li class="active"><a href="ch01-en.html">Chapters</a><ul class="vertical menu"><li><a href="ch01-en.html">1. Software Heritage: the universal archive of software
               source codes</a><ul class="vertical menu"><li><a href="ch01-en.html#ch01-sub01-en">A complex task</a></li><li><a href="ch01-en.html#ch01-sub02-en">A universal mission</a></li><li><a href="ch01-en.html#ch01-sub03-en">Past, present, future: much more than an
                  archive!</a></li><li><a href="ch01-en.html#ch01-sub04-en">A strategic issue, which needs to be known</a></li></ul></li><li class="active"><a href="ch02-en.html">2. Development and obsolescence of programs – the
               programmer’s challenge and nightmare</a></li><li><a href="ch03-en.html">3. From BESS to EVA, archival challenge</a><ul class="vertical menu"><li><a href="ch03-en.html#ch03-sub01-en">1. Introduction</a></li><li><a href="ch03-en.html#ch03-sub02-en">2. STRUCTRAN</a></li><li><a href="ch03-en.html#ch03-sub03-en">3. From BESS to EVA</a></li><li><a href="ch03-en.html#ch03-sub04-en">4. NEVA</a></li><li><a href="ch03-en.html#ch03-sub05-en">5. Archival challenge</a></li></ul></li><li><a href="ch04-en.html">4. Towards the sustained use of software for long-term
               access to digital heritage</a><ul class="vertical menu"><li><a href="ch04-en.html#ch04-sub01-en">Digital media</a></li><li><a href="ch04-en.html#ch04-sub02-en">Digital continuity and the importance of
                  software</a></li><li><a href="ch04-en.html#ch04-sub03-en">Software history and rate of obsolescence</a></li><li><a href="ch04-en.html#ch04-sub04-en">Software library for legacy software</a></li><li><a href="ch04-en.html#ch04-sub05-en">Reconstruction of data analyses</a></li><li><a href="ch04-en.html#ch04-sub06-en">Reconstruction of digital art</a></li><li><a href="ch04-en.html#ch04-sub07-en">Long-term care of software</a></li></ul></li><li><a href="ch05-en.html">5. Partner – Forever young</a><ul class="vertical menu"><li><a href="ch05-en.html#ch05-sub01-en">The Iskra Delta Partner Computer</a></li><li><a href="ch05-en.html#ch05-sub02-en">Emulating the Partner environment</a></li><li><a href="ch05-en.html#ch05-sub03-en">Partner software is a rarity and a historical
                  curiosity</a></li><li><a href="ch05-en.html#ch05-sub04-en">Archiving software as a core museum procedure</a></li><li><a href="ch05-en.html#ch05-sub05-en">The inseparable entities of the user and the
                  machine</a></li><li><a href="ch05-en.html#ch05-sub06-en">Conclusion</a></li><li><a href="ch05-en.html#ch05-sub07-en">Postscript</a></li></ul></li><li><a href="ch06-en.html">6. Legal challenges of archiving software</a><ul class="vertical menu"><li><a href="ch06-en.html#ch06-sub01-en">“Intellectual property” rights</a><ul class="vertical menu"><li><a href="ch06-en.html#ch06-sub01.1-en">Copyright</a></li><li><a href="ch06-en.html#ch06-sub01.2-en">Patents</a></li><li><a href="ch06-en.html#ch06-sub01.3-en">Trademarks &amp; service marks</a></li><li><a href="ch06-en.html#ch06-sub01.4-en">Data in/with software</a><ul class="vertical menu"><li><a href="ch06-en.html#ch06-sub01.4.1-en">Data</a></li><li><a href="ch06-en.html#ch06-sub01.4.2-en">Database</a></li></ul></li><li><a href="ch06-en.html#ch06-sub01.5-en">Design &amp; UI/UX in software</a></li><li><a href="ch06-en.html#ch06-sub01.6-en">Hardware</a><ul class="vertical menu"><li><a href="ch06-en.html#ch06-sub01.6.1-en">Hardware circuits, schematics, etc.</a></li></ul></li></ul></li><li><a href="ch06-en.html#ch06-sub02-en">Domain names</a><ul class="vertical menu"><li><a href="ch06-en.html#ch06-sub02.1-en">Internet domain names</a></li></ul></li><li><a href="ch06-en.html#ch06-sub03-en">How to obtain rights</a><ul class="vertical menu"><li><a href="ch06-en.html#ch06-sub03.1-en">Free (as in “freedom”)</a></li><li><a href="ch06-en.html#ch06-sub03.2-en">Exceptions by law</a></li><li><a href="ch06-en.html#ch06-sub03.3-en">License</a></li><li><a href="ch06-en.html#ch06-sub03.4-en">Public bodies</a></li></ul></li><li><a href="ch06-en.html#ch06-sub04-en">Other considerations</a></li></ul></li><li><a href="ch07-en.html">7. Pioneering Computer Support in Urban Planning,
               1970–1985</a><ul class="vertical menu"><li><a href="ch07-en.html#ch07-sub01-en">1. Introduction</a></li><li><a href="ch07-en.html#ch07-sub02-en">2. Information system for spatial planning</a></li><li><a href="ch07-en.html#ch07-sub03-en">3. Data capture example: centroids of house
                  numbers</a></li><li><a href="ch07-en.html#ch07-sub04-en">4. Data output example: first digital maps</a></li><li><a href="ch07-en.html#ch07-sub05-en">5. Methods example: expert systems</a></li><li><a href="ch07-en.html#ch07-sub06-en">6. Implementations: Celje and Ljubljana
                  municipalities</a></li><li><a href="ch07-en.html#ch07-sub07-en">7. Implementation: Guyana</a></li><li><a href="ch07-en.html#ch07-sub08-en">8. Comparisons and disseminations</a></li><li><a href="ch07-en.html#ch07-sub09-en">9. After 50 years</a></li></ul></li><li><a href="ch08-en.html">8. Are values in software development time-critical or
               can they be stored?</a><ul class="vertical menu"><li><a href="ch08-en.html#ch08-sub01-en">VSD Empirical Investigation – HERMES SoftLab,
                  Slovenia</a></li><li><a href="ch08-en.html#ch08-sub02-en">Current conclusion</a></li></ul></li></ul></li><li><a href="study01-en.html">Biographies</a></li><li><a href="#">English</a><ul class="menu"><li><a href="ch02.html">Slovenščina</a></li></ul></li></ul></div></div></div></div><div class="show-for-large"><nav class="title-bar"><div class="title-bar-left"><a class="title-bar-title" href="https://sistory.github.io/TheLegacyofAdvancedInformatization"><i class="fi-home" style="color:white;"></i> <span>Domov</span></a></div><div class="title-bar-right"><ul class="dropdown menu" data-dropdown-menu=""><li><a href="index.html">Cover Page</a></li><li><a href="cip.html">Colophon</a></li><li><a href="toc.html">TOC</a></li><li><a href="preface-en.html">Front</a></li><li class="active"><a href="ch01-en.html">Chapters</a><ul class="menu"><li><a href="ch01-en.html">1. Software Heritage: the universal archive of software
               source codes</a><ul class="menu"><li><a href="ch01-en.html#ch01-sub01-en">A complex task</a></li><li><a href="ch01-en.html#ch01-sub02-en">A universal mission</a></li><li><a href="ch01-en.html#ch01-sub03-en">Past, present, future: much more than an
                  archive!</a></li><li><a href="ch01-en.html#ch01-sub04-en">A strategic issue, which needs to be known</a></li></ul></li><li class="active"><a href="ch02-en.html">2. Development and obsolescence of programs – the
               programmer’s challenge and nightmare</a></li><li><a href="ch03-en.html">3. From BESS to EVA, archival challenge</a><ul class="menu"><li><a href="ch03-en.html#ch03-sub01-en">1. Introduction</a></li><li><a href="ch03-en.html#ch03-sub02-en">2. STRUCTRAN</a></li><li><a href="ch03-en.html#ch03-sub03-en">3. From BESS to EVA</a></li><li><a href="ch03-en.html#ch03-sub04-en">4. NEVA</a></li><li><a href="ch03-en.html#ch03-sub05-en">5. Archival challenge</a></li></ul></li><li><a href="ch04-en.html">4. Towards the sustained use of software for long-term
               access to digital heritage</a><ul class="menu"><li><a href="ch04-en.html#ch04-sub01-en">Digital media</a></li><li><a href="ch04-en.html#ch04-sub02-en">Digital continuity and the importance of
                  software</a></li><li><a href="ch04-en.html#ch04-sub03-en">Software history and rate of obsolescence</a></li><li><a href="ch04-en.html#ch04-sub04-en">Software library for legacy software</a></li><li><a href="ch04-en.html#ch04-sub05-en">Reconstruction of data analyses</a></li><li><a href="ch04-en.html#ch04-sub06-en">Reconstruction of digital art</a></li><li><a href="ch04-en.html#ch04-sub07-en">Long-term care of software</a></li></ul></li><li><a href="ch05-en.html">5. Partner – Forever young</a><ul class="menu"><li><a href="ch05-en.html#ch05-sub01-en">The Iskra Delta Partner Computer</a></li><li><a href="ch05-en.html#ch05-sub02-en">Emulating the Partner environment</a></li><li><a href="ch05-en.html#ch05-sub03-en">Partner software is a rarity and a historical
                  curiosity</a></li><li><a href="ch05-en.html#ch05-sub04-en">Archiving software as a core museum procedure</a></li><li><a href="ch05-en.html#ch05-sub05-en">The inseparable entities of the user and the
                  machine</a></li><li><a href="ch05-en.html#ch05-sub06-en">Conclusion</a></li><li><a href="ch05-en.html#ch05-sub07-en">Postscript</a></li></ul></li><li><a href="ch06-en.html">6. Legal challenges of archiving software</a><ul class="menu"><li><a href="ch06-en.html#ch06-sub01-en">“Intellectual property” rights</a><ul class="menu"><li><a href="ch06-en.html#ch06-sub01.1-en">Copyright</a></li><li><a href="ch06-en.html#ch06-sub01.2-en">Patents</a></li><li><a href="ch06-en.html#ch06-sub01.3-en">Trademarks &amp; service marks</a></li><li><a href="ch06-en.html#ch06-sub01.4-en">Data in/with software</a><ul class="menu"><li><a href="ch06-en.html#ch06-sub01.4.1-en">Data</a></li><li><a href="ch06-en.html#ch06-sub01.4.2-en">Database</a></li></ul></li><li><a href="ch06-en.html#ch06-sub01.5-en">Design &amp; UI/UX in software</a></li><li><a href="ch06-en.html#ch06-sub01.6-en">Hardware</a><ul class="menu"><li><a href="ch06-en.html#ch06-sub01.6.1-en">Hardware circuits, schematics, etc.</a></li></ul></li></ul></li><li><a href="ch06-en.html#ch06-sub02-en">Domain names</a><ul class="menu"><li><a href="ch06-en.html#ch06-sub02.1-en">Internet domain names</a></li></ul></li><li><a href="ch06-en.html#ch06-sub03-en">How to obtain rights</a><ul class="menu"><li><a href="ch06-en.html#ch06-sub03.1-en">Free (as in “freedom”)</a></li><li><a href="ch06-en.html#ch06-sub03.2-en">Exceptions by law</a></li><li><a href="ch06-en.html#ch06-sub03.3-en">License</a></li><li><a href="ch06-en.html#ch06-sub03.4-en">Public bodies</a></li></ul></li><li><a href="ch06-en.html#ch06-sub04-en">Other considerations</a></li></ul></li><li><a href="ch07-en.html">7. Pioneering Computer Support in Urban Planning,
               1970–1985</a><ul class="menu"><li><a href="ch07-en.html#ch07-sub01-en">1. Introduction</a></li><li><a href="ch07-en.html#ch07-sub02-en">2. Information system for spatial planning</a></li><li><a href="ch07-en.html#ch07-sub03-en">3. Data capture example: centroids of house
                  numbers</a></li><li><a href="ch07-en.html#ch07-sub04-en">4. Data output example: first digital maps</a></li><li><a href="ch07-en.html#ch07-sub05-en">5. Methods example: expert systems</a></li><li><a href="ch07-en.html#ch07-sub06-en">6. Implementations: Celje and Ljubljana
                  municipalities</a></li><li><a href="ch07-en.html#ch07-sub07-en">7. Implementation: Guyana</a></li><li><a href="ch07-en.html#ch07-sub08-en">8. Comparisons and disseminations</a></li><li><a href="ch07-en.html#ch07-sub09-en">9. After 50 years</a></li></ul></li><li><a href="ch08-en.html">8. Are values in software development time-critical or
               can they be stored?</a><ul class="menu"><li><a href="ch08-en.html#ch08-sub01-en">VSD Empirical Investigation – HERMES SoftLab,
                  Slovenia</a></li><li><a href="ch08-en.html#ch08-sub02-en">Current conclusion</a></li></ul></li></ul></li><li><a href="study01-en.html">Biographies</a></li><li><a href="#">English</a><ul class="menu"><li><a href="ch02.html">Slovenščina</a></li></ul></li></ul></div></nav></div><form action="search.html"><div class="row collapse"><div class="small-10 large-11 columns"><input type="text" name="q" id="tipue_search_input" placeholder="Your search text" /></div><div class="small-2 large-1 columns"><img type="button" class="tipue_search_button" /></div></div></form></header><section><div class="row"><div class="medium-2 columns show-for-medium"><p><a class="button" href="ch01-en.html" title="Previous: 1. Software Heritage: the universal archive of software source codes">&lt;&lt;</a></p></div><div class="medium-8 small-12 columns"><h2 lang="en" class="maintitle"><span class="head" itemprop="head" id="Legacy-head-24">2. Development and obsolescence of programs – the programmer’s challenge and nightmare</span></h2></div><div class="medium-2 columns show-for-medium text-right"><p><a class="button" href="ch03-en.html" title="Next: 3. From BESS to EVA, archival challenge">&gt;&gt;</a></p></div></div><div class="row hide-for-medium"><div class="small-6 columns text-center"><p><a class="button" href="ch01-en.html" title="Previous: 1. Software Heritage: the universal archive of software source codes">&lt;&lt;</a></p></div><div class="small-6 columns text-center"><p><a class="button" href="ch03-en.html" title="Next: 3. From BESS to EVA, archival challenge">&gt;&gt;</a></p></div></div><div lang="en" class="chapter" id="ch02-en"><p class="text-center"><b><a class="link_ref" itemprop="ref" href="study01-en.html#study01.5-en" title="Saša Divjak">Saša Divjak</a><br /></b></p><p style="text-align:justify;" id="Legacy-p-94">I belong to the older generation of programmers, with my first programming experience dating back to 1967 and the legendary Zuse Z32 computer. The beginning of the 1970s was marked by punched cards and perforated tape. Micro- and sometimes minicomputers were programmed in an interesting way back then. Computers were equipped with a teletype, a peripheral unit that allowed typing, printing, paper tape reading and punching. Software was prepared and run in this order:</p><p style="text-align:justify;" id="Legacy-p-95">The first step was to set the computer up with the text editor, saved as binary code on the tape. Then you wrote a program and punched the source code (often in assembly language) to a new tape. Next was reading of the assembler, which was again coded in binary form on a separate tape. And then reading of “your own” program in the source code could follow. As far as I can remember, reading was done in two steps as well because the assembler needed at least two phases to complete the process. Finally, if everything went (fairly) well, you could punch a new tape with your own program in binary code. Then came reading of the new binary program and its execution. What now takes a fraction of a second used to take quite a few minutes and you could only hope you hadn’t made a mistake, or the whole process had to be repeated.</p><p style="text-align:justify;" id="Legacy-p-96">When programming microcomputers, your own machine code program was usually “burned” into EPROM (an integrated circuit which formed part of the microcomputer’s memory). This is how we developed various microcomputer-supported automation protocols. But programmers tend to get things wrong. Because the whole cycle took a while to complete, we often (whenever possible) made corrections directly in the machine code, thus skipping the time-consuming punching process. As a result, the program worked correctly in EPROM, but the source code did not match anymore. Which is very wrong, of course.</p><p style="text-align:justify;" id="Legacy-p-97">Mentally jumping back and forth from assembly language to the machine code of the program was nothing special. Afterall back then , we often entered the bootstrap loader using the switches of the computer console. It became a habit, and it’s perhaps no surprise that we knew sequences of dozens of commands at the machine level by heart. This is an example of the kind of experience I had with the first generation of Digital PDP 11 computers in the 1970s.</p><p style="text-align:justify;" id="Legacy-p-98">Before I continue, I would like to point out that I lectured, at the Faculty of Computer and Information Science, on programming, systems software and operating systems, and, what I loved the most, computer graphics. This is reflected in some of the memories I mention further on.</p><p style="text-align:justify;" id="Legacy-p-99">There are now over 9,000 registered programming languages in the world, and the way we program computers has changed significantly. In the 1980s, we introduced the C programming language to the computer and information science study course at the then Faculty of Electrical Engineering and Computer Science, and to this day it serves as our “Latin”, and a solid foundation for many other programming languages. In 1997 we introduced the Java programming language. Being the main lecturer, I always worried about the constant development of this fresh programming language, which actually went through some major transformation in the following years. We used these programming languages for various projects.</p><p style="text-align:justify;" id="Legacy-p-100">On the other hand, in the late 1990s we already used JavaScript for programming web applications, and it is still just as popular. Later on object-oriented programming was joined by other approaches as they emerged. Among them was component-oriented programming, which used various problem-oriented libraries to build new applications by combining their own source code and function modules offered by the libraries. Why reinvent the wheel when solutions are already available? For instance, supporting 2D and 3D graphics or running various more or less complex, tested and effective routines? This type of approach requires the knowledge of APIs (Application Programming Interfaces), but speeds up the development process quite substantially. As a consequence, the rapid development of new versions eventually always leads to different components of our applications being incompatible with each other, therefore making the software obsolete. Particularly dangerous is the “mixing” of different technologies from different developers, who each follow their own standards and guidelines. One of the examples would be the now-forgotten Virtual Reality Markup Language (VRML), which emerged along with JavaScript and enabled quite decent 3D visualization and 3D scene animation at the time. Combining VRML and JavaScript languages enabled creating very attractive 3D visualizations and interactive simulations of natural phenomena. These examples are now completely obsolete, and can no longer be displayed (truth be told modern 3D graphics are something completely different). You may remember the Java applets, which enabled various applications (and 3D visualizations) in our browsers. Then it transpired that such technology had too many security flaws, because it could work outside of the advertised supposedly safe “sandbox”. One browser after another disabled these applets in their upgraded versions. Today it is only possible to see them only on computers with purposefully installed obsolete operating systems and browsers. Often we can achieve this using virtual machines on the computer. Developers were eager to find solutions in similar technologies in order to urgently address this issue. Many of them therefore switched back to the once-popular Flash and its programming language, called ActionScript. In some cases that helped preserve up to 80% of their code. Later it transpired we were hopelessly wrong. Flash, and ActionScript along with it, are now extinct. JavaScript and jQuery were the way to go, due to their high programming efficiency. Once again various libraries came in handy for the effective and uniform development of user interfaces and similar systems etc..</p><p style="text-align:justify;" id="Legacy-p-101">Nowadays we are surrounded by numerous mobile devices, such as smartphones, tablets and large or small laptops and desktop computers. Due to a large variety in screens, responsive design was developed to enable a similar user experience across all devices, regardless of the size and resolution of the screen. What is helpful in developing such applications? The jQuery Mobile library seems like a logical step, because it enables the planning of graphic user interfaces that can suit various devices. But there are other options, such as the popular Bootstrap. This was all well and good, but only for a short while, and jQuery was upgraded to the next versions (version 3 at the time of writing this paper). Development tools are suddenly able to send the developer warnings about parts of the code being obsolete or deprecated. If nothing else this is rather unpleasant, and we should worry about code that is becoming old and will probably become unusable over time. Well, we could migrate the code to comply with the new rules. This task, although time-consuming and painfully tedious because it requires a systematic approach, is necessary to keep track of progress. But there is a trap or two behind the corner. The development of jQuery Mobile stopped, for instance, and it no longer followed new versions of jQuery. We could do another migration or abandon the code of such an obsolete library.</p><p style="text-align:justify;" id="Legacy-p-102">Today we talk about extinct languages, and a programmer’s work is far from finished after an attractive application is complete. Its maintenance over time requires extra effort.</p><p style="text-align:justify;" id="Legacy-p-103">One of the questions a programmer may have is who to trust and follow so that his or her efforts do not go to waste too fast. Certain giant, global players could offer some answers, but even this is not risk-free. If I recall 3D graphics, I remember Microsoft’s Silverlight technology, which offered an array of beautiful 3D worlds and their animation. The trap this time was that it was a Microsoft product. Will others follow? Other operating systems exist beside Microsoft Windows. And so it happened that Silverlight did not catch on, and is now abandoned.</p><p style="text-align:justify;" id="Legacy-p-104">The dilemmas developers face nowadays are no different. The development of Android and iOS applications is very attractive due to the popularity of mobile devices. There are quite a few developer platforms available on the internet. But which ones do we think will last at least a little bit longer? And which will die out quickly? Is it React, or perhaps Flutter, which is based on a brand-new language called Dart? Why is this even necessary? We read forums and shape our opinions in the hope that our direction is the right one.</p><p style="text-align:justify;" id="Legacy-p-105">If we start a project from scratch, the first thing to do is to analyze the prevailing trends. Web applications and increasingly cloud computing are the most popular. For a while HTML5, CSS and AJAX/JSON have been the principal languages to use. JavaScript (or better yet JQuery) has superseded Flash. Applets have been long gone.</p><p style="text-align:justify;" id="Legacy-p-106">And program development has changed. Rapid incremental development with a sequential approach is gaining momentum. When designing one single project, programmers sometimes use various languages and have to know different APIs. Programs are increasingly complex.</p><p style="text-align:justify;" id="Legacy-p-107">One can observe the polarization of programming: On the one hand, we use high-level programming languages boosting programmers’ productivity, parallelization and ability to work in cloud environments. On the other hand, code effectiveness, execution speed and asymmetric calculations (also due to multi-core systems) can sometimes be important as well. Then there is “democratic” computing, which means that even a less knowledgeable (but motivated) user can develop a small segment, or at least tailor it to their needs. We must also not forget about “dangerous” computing. If something gets too complex a new framework can be designed, and it may upgrade the previous one. In this way, stacking looks a lot like a stack of dirty dishes, with ineffective code or security vulnerabilities somewhere within.</p><p style="text-align:justify;" id="Legacy-p-108">We may wonder what lies ahead. Let us not forget Moore’s famous law, which says that the number of transistors (i.e. the density of integrated circuits) doubles every two years. Then there are four laws postulated in 1997 by Nathan Myhrvold, formerly Chief Technology Officer at Microsoft, that discuss what is happening to programs. His laws of software spark off an interesting association with Newton’s laws. Let’s take a look.</p><p style="text-align:justify;" id="Legacy-p-109">1st Nathan’s law: Software is a gas.</p><p style="text-align:justify;" id="Legacy-p-110">It always expands to fit whatever container it is stored in (i.e. the computer’s capacity). Such expansion can be observed in numerous new versions of operating systems, such as Windows and Linux, and in the ever-growing length of browsers’ code.</p><p style="text-align:justify;" id="Legacy-p-111">2nd Nathan’s law: Software grows until it becomes limited by Moore’s law.</p><p style="text-align:justify;" id="Legacy-p-112">The growth of software is initially rapid, like a gas expanding, but is inevitably limited by the rate of increase in hardware speed. So every processor fails at one point. This usually happens just before new models see the light of day.</p><p style="text-align:justify;" id="Legacy-p-113">3rd Nathan’s law: Software growth makes Moore’s law possible.</p><p style="text-align:justify;" id="Legacy-p-114">People buy new hardware because the software requires it. Integrated circuits are faster than ever, but the price of computers remains more or less the same. We get better value for our money. This phenomenon goes on and on, because new programs emerge all the time.</p><p style="text-align:justify;" id="Legacy-p-115">4th Nathan’s law: Software is limited only by human ambition and expectation.</p><p style="text-align:justify;" id="Legacy-p-116">We never get enough. We get to work with new applications and new ideas of what is popular.</p><p style="text-align:justify;" id="Legacy-p-117">Programs and programming are always in a state of crisis. Whatever we achieve rarely meets the expectations of the users. The bar of expectation is constantly rising.</p><p style="text-align:justify;" id="Legacy-p-118">Programming is challenging even for experienced programmers. We constantly switch from one thought model to another, and translate various solutions to the code and back. In fact, programs are abstractions, and we often use concrete examples to understand them.</p><p style="text-align:justify;" id="Legacy-p-119">Also helpful are approaches such as object-oriented programming, and the use of high-level programming languages. Another common practice is the copy/paste approach, which is based on using code snippets.</p><p style="text-align:justify;" id="Legacy-p-120">It is a well-known fact that even children can understand something better with a visual example. We can easily understand what we feel, but words have to be analyzed first to get to their meaning. Short sentences are not a problem. Long texts, however, are more time-consuming and exhausting. And program code is no different. Some source programs are difficult to understand and sometimes it is easier to develop them from scratch.</p><p style="text-align:justify;" id="Legacy-p-121">It is true that programming languages are intended for people, not computers, and that we are still at the dawn of the history of programming. We took a leap from punched cards and tapes to interactive work behind computer screens. The next shift will have to take into account the fact that in a few decades we expect computers to have a human intelligence level. How will we program such computers? Will they learn the skills by themselves? Will they come up with new standards? The future will be exciting. And perhaps we should be worried.</p></div><div class="row"><div class="small-6 columns text-center"><p><a class="button" href="ch01-en.html" title="Previous: 1. Software Heritage: the universal archive of software source codes">&lt;&lt;</a></p></div><div class="small-6 columns text-center"><p><a class="button" href="ch03-en.html" title="Next: 3. From BESS to EVA, archival challenge">&gt;&gt;</a></p></div></div></section></div><script src="https://www2.sistory.si/publikacije/themes/foundation/6/js/vendor/what-input.js"></script><script src="https://www2.sistory.si/publikacije/themes/foundation/6/js/vendor/foundation.min.js"></script><script src="https://www2.sistory.si/publikacije/themes/foundation/6/js/app.js"></script><script src="https://www2.sistory.si/publikacije/themes/js/plugin/back-to-top/back-to-top.js"></script></body></html>